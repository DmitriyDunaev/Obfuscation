#define PSEUDOCODE

#if !PSEUDOCODE

/*
 * So this is the algorithm for meshing the control flow transition blocks.
 * This algorithm can be divided into two main parts:
 *  - Meshing the unconditional jumps
 *  - Meshing the conditional jumps
 * 
 * The complexity of the final CFG is based on the CFT Ratio, or Control Flow Transition
 * Ratio, which is the basic parameter of this algorithm of the obfuscaion. Depending on
 * this, the run time of the obfuscated part obviously slow down, so further considerations
 * must be done to set the default value of the CFT Ratio.
 * 
 * First of all, the algorithm needs a set of jumps -- conditional and unconditional also
 * -- on which the meshing will be terminated. The setting of this set is the first step,
 * becouse if we mesh up the CFG based on the unconditional jumps, and we try to determine
 * the conditional jumps which will locate the place of the meshing by the conditional
 * jumps, we might face the situation that for instance we only mesh up the conditional
 * jumps which are generated by us erstwhile, the original conditional jumps will remain
 * unmeshed... this explanation is getting to be too verbosed, so the point is: the first
 * step is to define the several jumps which the mesh will be based on.
 */

// Dmitriy: Agree on that, but we can easily solve it. Let's discuss it on Friday!


/*
 * This is the main function, it meshes up the single unconditional and
 * unconditional jumps,
 */

void MeshFunction( Function actualfunction)
{
    /*
     * The getBBCunJumps returns a list of the basic blocks that has an
     * one successor, wich also has a sucessor. Not all of them, but some,
     * depending on the CFTRatio.
     */
    
    list<BasicBlock> basicblocks = Function::getBBUncJumps( actualfunction );
    
    /*
     * Now we go through the list, and mesh the jumps.
     */
    
    foreach ( BasicBlock bb in basicblocks )
        MeshUnconditional( bb )
    
    /*
     * Now we need the list of the conditional jumps.
     */
    
    basicblocks = Function::getBBCondJumps( actualfunction );
    
    /*
     * And go through the list of conditional jumps as well.
     */
    
    foreach ( BasicBlock bb in basicblocks )
        MeshConditional( bb );
}

/*
 * The MeshUncoditional function gets a BasicBlock, and creates
 * the Control Flow Transition.
 */

void MeshUnconditional( BasicBlock actualbb )
{
    /* First we insert an entry point. */
    
    BasicBlosk ep = InsertEntryPoint( actualbb );
    
    /* Next, we insert the fake flow, with one fake block, and
     * we create a copy of the successor of the actual basic block. */
    
    InsertFakeFlow( actualbb );
    
    /* Finally comes the dead flow, with 3 blocks. They are all dead. */
    
    InsertDeadFlow( ep );
}

/*
 * The InsertEntryPoint is the function that inserts the fake basic block
 * which will serve as the entry point of the CFT.
 */
void InsertEntryPoint( BasicBlock bb )
{
    /* We need a new BB. */

    BasicBlock ep = new BasicBlock();

    /* Some function now creates an instruction with a fake conditional jump,
     * and it is fake becouse it always continues in the true way. */

    Instruction i = CreateFakeCondJump( bb.Instructions[0].getID() );

    /* Appending the instruction to the block we just created. */
    
    ep.Append( i );

    /* And setting its successor to the actual block. */

    ep.Successors.Add( bb );

    /* Now we use the ChangeGotos function, and it changes all goto-s in the
     * function with one ID, to have an other ID */

    bb.parent.ChangeGotos( bb.Instructions[0].getID(), ep.Instructions[0].getID() );

    /* And finally we set the bacisblocks' predecessors and successors, so
     * the edges in the CFG. */
    
    foreach ( BasicBlock pred in pp.Predecessors )
    {
        pred.Successors.Delete( bb );
        pred.Successors.Add( ep );
        bb.Predecessors.Delete( pred );
    }
    bb.Predecessors.Add( ep );   
}

/*
 * Now we can proceed to the second step, wich means inserting the fake side of the
 * meshed control flow. The fake path looks like this:
 * 
 *           ------------------
 *          | Fake entry block |
 *           ------------------
 *        (True) /
 *          -----------
 *         | Actual BB |
 *          -----------
 *    (False) /   \ (True)
 *    ------------ \
 *   | Fake Block | |
 *    ------------ /
 *   |  Actual    |
 *   | Successor  |
 *    ------------
 *    
 * Since we have the injected entry point, this part of the algorythm includes changing
 * the unconditional jump of the actual basicblock into a conditional jump, with the
 * following ends: The true lane must go to the actual successor and the false must go
 * to the fake block. (Becouse of the future code generation, it cannot be solved that
 * the true lane would be followed immediatelly by the false...)
 */

void InsertFakeFlow( BasicBlock bb )
{
    // succ will be the only successor of bb. It onnly have one, becouse there is 
    // an unconditional jump at the end of it.

    BaisBlock succ = bb.Successors[0];

    // Creating a new basic block, that'll be our fake block.

    BasicBlock fake = new BasicBlock()

    // We fill it with fake code. Todo: Create this alg.

    FillWithFakeCode( fake );

    // Changing the conditional jump for unconditional. Todo: Create this also.

    ChangeToCond( bb.Instructions[ bb.InstructionNumber() - 1 ] );

    // And finally we set the edges -> successors and predecessors.

    fake.Successors.Add( succ );
    bb.Successors.Add( fake );
    fake.Predecessors.Add( bb );
    succ.Predecessors.Add( fake );
   
}

ChangeToCond( Instruction );


/* Still to do:
 * 
 * void InsertFakeFlow();
 * void InsertDeadFlow();
 * 
 * void MeshConditional();
 */

#endif